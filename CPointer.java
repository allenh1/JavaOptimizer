/**
 * This interface represents a pointer in C. We will extend this for various data types
 * to make pointers, for most data types, available in Java. This class will be used in
 * the code generated by the C++ code.
 */

public abstract class CPointer
{
    private byte[] memory;
    private boolean isSet;

    private int index;
    private int size;

    public CPointer() {
        isSet  = false;
        memory = new byte[0];
        size = 0; index = 0;
    }

    public CPointer(CPointer other) {
        memory = other.getBytes();
        isSet  = other.isSet();
        size   = other.getSize();
        index  = other.getIndex();
    }

    public CPointer (int size) {
        memory    = new byte[size];
        this.size = size;
        isSet     = true;
        index     = 0;
    }

    /**
     * This is how we tell if something is null.
     *
     * @return     Returns true if allocated, false otherwise.
     */
    public boolean isSet() { return isSet; }
    
    /**
     * This function returns the array at which we point.
     *
     * @return     Array object, in bytes.
     */
    public byte[] getBytes(){ return memory; }

    /**
     * This returns the size of the object at which we point.
     *
     * @return     Size in bytes.
     */
    public int getSize(){ return size; }

    /**
     * This returns the current index of the pointer.
     * 
     * @return     Current location after beginning. 
     */
    public int getIndex(){ return index;}
    /**
     * Increment the pointer. We do not change location in memory.
     */
    public void PlusPlus() { index++; }

    public void setBytes(byte[] other) {
        memory = new byte[other.length];
        for (int x = 0; x < other.length; ++x)
            memory[x] = other[x];
        isSet = true;
    }
    public byte get(int index) { return (index < memory.length) ? memory[index] : 0; }
    public byte value() { return memory[index]; }
    
    /**
     * Makes a pointer of a particular type and returns it.
     * This is basically a converter. Think of an address
     * function.
     *
     * @param      o     Object at which to point.
     *
     * @return     A byte array containing o.
     */
    public abstract byte[] javaToCPointer(Object o);

    /**
     * This is a "malloc" function. Though we can't really
     * create a <t>real</t> malloc function, this will do.
     *
     * @param      size  Number of bytes to allocate.
     *
     * @return     Array of size consecutive bytes.
     */
    public static byte[] malloc(int size) {
        byte[] myArray = new byte[size];
        return myArray;
    }
}